"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[19],{9024:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>r});var o=t(4848),s=t(8453);const l={},a="useTextMoodProcessor",i={id:"hooks/use-text-mood-processor",title:"useTextMoodProcessor",description:"The useTextMoodProcessor hook manages the state and logic for analyzing text mood and changing the tone of the text. It integrates both tone analysis and tone change functionality, providing a cohesive way to handle text mood processing in your application.",source:"@site/docs/hooks/use-text-mood-processor.md",sourceDirName:"hooks",slug:"/hooks/use-text-mood-processor",permalink:"/text_mood_processor_frontend/hooks/use-text-mood-processor",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"useChangeTone",permalink:"/text_mood_processor_frontend/hooks/use-change-tone"}},c={},r=[{value:"State Variables",id:"state-variables",level:2},{value:"<code>text: string</code>",id:"text-string",level:3},{value:"<code>selectedTone: string</code>",id:"selectedtone-string",level:3},{value:"<code>analyzeResult: AnalyzeResult | null</code>",id:"analyzeresult-analyzeresult--null",level:3},{value:"<code>changeToneResult: ChangeToneResult | null</code>",id:"changetoneresult-changetoneresult--null",level:3},{value:"<code>showToneSelector: boolean</code>",id:"showtoneselector-boolean",level:3},{value:"Functions",id:"functions",level:2},{value:"<code>handleAnalyzeTone: () =&gt; Promise&lt;void&gt;</code>",id:"handleanalyzetone---promisevoid",level:3},{value:"<code>handleChangeTone: () =&gt; void</code>",id:"handlechangetone---void",level:3},{value:"<code>handleAcceptToneChange: () =&gt; Promise&lt;void&gt;</code>",id:"handleaccepttonechange---promisevoid",level:3},{value:"<code>setShowToneSelector: (boolean) =&gt; void</code>",id:"setshowtoneselector-boolean--void",level:3},{value:"Usage Example",id:"usage-example",level:2},{value:"AnalyzeResult and ChangeToneResult Types",id:"analyzeresult-and-changetoneresult-types",level:3},{value:"How It Works",id:"how-it-works",level:2},{value:"Conclusion",id:"conclusion",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"usetextmoodprocessor",children:"useTextMoodProcessor"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useTextMoodProcessor"})," hook manages the state and logic for analyzing text mood and changing the tone of the text. It integrates both tone analysis and tone change functionality, providing a cohesive way to handle text mood processing in your application."]}),"\n",(0,o.jsx)(n.h2,{id:"state-variables",children:"State Variables"}),"\n",(0,o.jsx)(n.h3,{id:"text-string",children:(0,o.jsx)(n.code,{children:"text: string"})}),"\n",(0,o.jsxs)(n.p,{children:["The current value of the text entered by the user. This state is updated through the ",(0,o.jsx)(n.code,{children:"setText"})," function."]}),"\n",(0,o.jsx)(n.h3,{id:"selectedtone-string",children:(0,o.jsx)(n.code,{children:"selectedTone: string"})}),"\n",(0,o.jsxs)(n.p,{children:["The currently selected tone for changing the text's mood. This state is updated by the user through the tone selector and can be managed with the ",(0,o.jsx)(n.code,{children:"setSelectedTone"})," function."]}),"\n",(0,o.jsx)(n.h3,{id:"analyzeresult-analyzeresult--null",children:(0,o.jsx)(n.code,{children:"analyzeResult: AnalyzeResult | null"})}),"\n",(0,o.jsx)(n.p,{children:"The result of the tone analysis. This state is updated when a successful analysis occurs and is reset when the tone is changed."}),"\n",(0,o.jsx)(n.h3,{id:"changetoneresult-changetoneresult--null",children:(0,o.jsx)(n.code,{children:"changeToneResult: ChangeToneResult | null"})}),"\n",(0,o.jsx)(n.p,{children:"The result of the tone change. This state is updated when a successful tone change occurs and is reset when a new tone analysis is performed."}),"\n",(0,o.jsx)(n.h3,{id:"showtoneselector-boolean",children:(0,o.jsx)(n.code,{children:"showToneSelector: boolean"})}),"\n",(0,o.jsx)(n.p,{children:"A boolean flag indicating whether the tone selector should be displayed. This state is used to control the visibility of the tone selector when the user decides to change the tone."}),"\n",(0,o.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,o.jsx)(n.h3,{id:"handleanalyzetone---promisevoid",children:(0,o.jsx)(n.code,{children:"handleAnalyzeTone: () => Promise<void>"})}),"\n",(0,o.jsxs)(n.p,{children:["Initiates the tone analysis process. It checks if the entered text has at least 50 characters before calling the ",(0,o.jsx)(n.code,{children:"analyzeTone"})," function from the ",(0,o.jsx)(n.code,{children:"useAnalyzeTone"})," hook. If the analysis is successful, the result is stored in the ",(0,o.jsx)(n.code,{children:"analyzeResult"})," state, and any previous tone change result is cleared."]}),"\n",(0,o.jsx)(n.h3,{id:"handlechangetone---void",children:(0,o.jsx)(n.code,{children:"handleChangeTone: () => void"})}),"\n",(0,o.jsxs)(n.p,{children:["Prepares for the tone change process. It checks if the text has at least 50 characters before showing the tone selector by setting the ",(0,o.jsx)(n.code,{children:"showToneSelector"})," state to ",(0,o.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"handleaccepttonechange---promisevoid",children:(0,o.jsx)(n.code,{children:"handleAcceptToneChange: () => Promise<void>"})}),"\n",(0,o.jsxs)(n.p,{children:["Executes the tone change process. It checks if a tone is selected, then calls the ",(0,o.jsx)(n.code,{children:"changeTone"})," function from the ",(0,o.jsx)(n.code,{children:"useChangeTone"})," hook. If the tone change is successful, the result is stored in the ",(0,o.jsx)(n.code,{children:"changeToneResult"})," state, the tone analysis result is cleared, and the tone selector is hidden."]}),"\n",(0,o.jsx)(n.h3,{id:"setshowtoneselector-boolean--void",children:(0,o.jsx)(n.code,{children:"setShowToneSelector: (boolean) => void"})}),"\n",(0,o.jsx)(n.p,{children:"A function to manually control the visibility of the tone selector, useful for closing the selector or showing it again based on user interactions."}),"\n",(0,o.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'import React from \'react\';\nimport useTextMoodProcessor from \'./useTextMoodProcessor\';\n\nconst TextMoodProcessorComponent = () => {\n  const {\n    text,\n    setText,\n    selectedTone,\n    setSelectedTone,\n    analyzeResult,\n    changeToneResult,\n    showToneSelector,\n    handleAnalyzeTone,\n    handleChangeTone,\n    handleAcceptToneChange,\n    setShowToneSelector\n  } = useTextMoodProcessor();\n\n  return (\n    <div>\n      <textarea value={text} onChange={(e) => setText(e.target.value)} />\n      \n      <button onClick={handleAnalyzeTone} disabled={text.length < 50}>\n        Analyze Tone\n      </button>\n      \n      <button onClick={handleChangeTone} disabled={text.length < 50}>\n        Change Tone\n      </button>\n      \n      {analyzeResult && <div>{JSON.stringify(analyzeResult)}</div>}\n      {changeToneResult && <div>{JSON.stringify(changeToneResult)}</div>}\n      \n      {showToneSelector && (\n        <div>\n          <select value={selectedTone} onChange={(e) => setSelectedTone(e.target.value)}>\n            <option value="friendly">Friendly</option>\n            <option value="serious">Serious</option>\n            <option value="funny">Funny</option>\n          </select>\n          <button onClick={handleAcceptToneChange}>Accept Tone Change</button>\n          <button onClick={() => setShowToneSelector(false)}>Cancel</button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default TextMoodProcessorComponent;\n'})}),"\n",(0,o.jsx)(n.h3,{id:"analyzeresult-and-changetoneresult-types",children:"AnalyzeResult and ChangeToneResult Types"}),"\n",(0,o.jsx)(n.p,{children:"The AnalyzeResult and ChangeToneResult types define the structure of the data returned by the respective tone analysis and tone change functions. They are imported from the types file."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export interface AnalyzeResult {\n  emotions: {\n    emotion: string;\n    percentage: number;\n  }[];\n  predominant_emotion: string;\n  confidence: number;\n}\n\nexport interface ChangeToneResult {\n  original_text: string;\n  modified_text: string;\n  applied_tone: string;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Analyze Text Tone:"})}),"\n"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:'When the user clicks "Analyze Tone", the text is analyzed, and the results are stored in analyzeResult.'}),"\n",(0,o.jsx)(n.li,{children:"A minimum of 50 characters is required to perform the analysis."}),"\n"]}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Change Text Tone:"})}),"\n"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:'When the user clicks "Change Tone", the tone selector is displayed, allowing the user to choose a tone (e.g., friendly, serious, funny).'}),"\n",(0,o.jsx)(n.li,{children:"Upon accepting the tone change, the modified text and applied tone are stored in changeToneResult."}),"\n"]}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Interaction:"})}),"\n"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Once the analysis is performed, the result is cleared when the tone is changed."}),"\n",(0,o.jsx)(n.li,{children:"The user can toggle the tone selector on and off manually."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"The useTextMoodProcessor hook provides a complete solution for handling text mood analysis and tone changes in a React component. It abstracts the logic for analyzing the text and changing its tone, making it easy to manage the state and interactions in your UI."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var o=t(6540);const s={},l=o.createContext(s);function a(e){const n=o.useContext(l);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);